
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../surfaces/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.9">
    
    
      
        <title>Generators - OgreInterface Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.0d440cfe.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.2505c338.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#generatepy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="OgreInterface Documentation" class="md-header__button md-logo" aria-label="OgreInterface Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            OgreInterface Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Generators
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="OgreInterface Documentation" class="md-nav__button md-logo" aria-label="OgreInterface Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    OgreInterface Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          API
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          API
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Generators
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Generators
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#generatepy" class="md-nav__link">
    generate.py
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate" class="md-nav__link">
    OgreInterface.generate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.InterfaceGenerator" class="md-nav__link">
    InterfaceGenerator
  </a>
  
    <nav class="md-nav" aria-label="InterfaceGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.InterfaceGenerator.generate_interfaces" class="md-nav__link">
    generate_interfaces()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.OrganicSurfaceGenerator" class="md-nav__link">
    OrganicSurfaceGenerator
  </a>
  
    <nav class="md-nav" aria-label="OrganicSurfaceGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.OrganicSurfaceGenerator.from_file" class="md-nav__link">
    from_file()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator" class="md-nav__link">
    SurfaceGenerator
  </a>
  
    <nav class="md-nav" aria-label="SurfaceGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.nslabs" class="md-nav__link">
    nslabs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.terminations" class="md-nav__link">
    terminations
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.from_file" class="md-nav__link">
    from_file()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.generate_slabs" class="md-nav__link">
    generate_slabs()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.TolarenceError" class="md-nav__link">
    TolarenceError
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../surfaces/" class="md-nav__link">
        Surfaces
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../miller/" class="md-nav__link">
        Miller Index Scan
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../lattice_match/" class="md-nav__link">
        Zur and McGill Algorithm
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6" >
      
      
      
        <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
          Surface Matching
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_6">
          <span class="md-nav__icon md-icon"></span>
          Surface Matching
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../surface_match/ionic_surface_matcher/" class="md-nav__link">
        Ionic surface matcher
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../surface_match/sphere_surface_matcher/" class="md-nav__link">
        Sphere surface matcher
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_7" >
      
      
      
        <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
          Score Function
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_7">
          <span class="md-nav__icon md-icon"></span>
          Score Function
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../score_function/born/" class="md-nav__link">
        Born
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../score_function/ewald/" class="md-nav__link">
        Ewald
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../score_function/overlap/" class="md-nav__link">
        Overlap
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#generatepy" class="md-nav__link">
    generate.py
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate" class="md-nav__link">
    OgreInterface.generate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.InterfaceGenerator" class="md-nav__link">
    InterfaceGenerator
  </a>
  
    <nav class="md-nav" aria-label="InterfaceGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.InterfaceGenerator.generate_interfaces" class="md-nav__link">
    generate_interfaces()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.OrganicSurfaceGenerator" class="md-nav__link">
    OrganicSurfaceGenerator
  </a>
  
    <nav class="md-nav" aria-label="OrganicSurfaceGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.OrganicSurfaceGenerator.from_file" class="md-nav__link">
    from_file()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator" class="md-nav__link">
    SurfaceGenerator
  </a>
  
    <nav class="md-nav" aria-label="SurfaceGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.nslabs" class="md-nav__link">
    nslabs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.terminations" class="md-nav__link">
    terminations
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.from_file" class="md-nav__link">
    from_file()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#OgreInterface.generate.SurfaceGenerator.generate_slabs" class="md-nav__link">
    generate_slabs()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#OgreInterface.generate.TolarenceError" class="md-nav__link">
    TolarenceError
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Generators</h1>

<h2 id="generatepy">generate.py</h2>


<div class="doc doc-object doc-module">


<a id="OgreInterface.generate"></a>
  <div class="doc doc-contents first">
  
      <p>This module will be used to construct the surfaces and interfaces used in this package.</p>

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="OgreInterface.generate.InterfaceGenerator" class="doc doc-heading">
        <code>InterfaceGenerator</code>


</h2>


  <div class="doc doc-contents ">

  
      <p>Class for generating interfaces from two bulk structures</p>
<p>This class will use the lattice matching algorithm from Zur and McGill to generate
commensurate interface structures between two inorganic crystalline materials.</p>

<p><strong>Examples:</strong></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">OgreInterface.generate</span> <span class="kn">import</span> <span class="n">SurfaceGenerator</span><span class="p">,</span> <span class="n">InterfaceGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subs</span> <span class="o">=</span> <span class="n">SurfaceGenerator</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;POSCAR_sub&quot;</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">layers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">films</span> <span class="o">=</span> <span class="n">SurfaceGenerator</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;POSCAR_film&quot;</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">layers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interface_generator</span> <span class="o">=</span> <span class="n">InterfaceGenerator</span><span class="p">(</span><span class="n">substrate</span><span class="o">=</span><span class="n">subs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">film</span><span class="o">=</span><span class="n">films</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">interface_generator</span><span class="o">.</span><span class="n">generate_interfaces</span><span class="p">()</span> <span class="c1"># List of OgreInterface Interface objects</span>
</code></pre></div>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>substrate</code></td>
          <td>
                <code><a class="autorefs autorefs-internal" title="OgreInterface.surfaces.Surface" href="../surfaces/#OgreInterface.surfaces.Surface">Surface</a></code>
          </td>
          <td><p>Surface class of the substrate material</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>film</code></td>
          <td>
                <code><a class="autorefs autorefs-internal" title="OgreInterface.surfaces.Surface" href="../surfaces/#OgreInterface.surfaces.Surface">Surface</a></code>
          </td>
          <td><p>Surface class of the film materials</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_area_mismatch</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Tolarance of the area mismatch (eq. 2.1 in Zur and McGill)</p></td>
          <td>
                <code>0.01</code>
          </td>
        </tr>
        <tr>
          <td><code>max_angle_strain</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Tolarence of the angle mismatch between the film and substrate lattice vectors</p></td>
          <td>
                <code>0.01</code>
          </td>
        </tr>
        <tr>
          <td><code>max_linear_strain</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Tolarence of the length mismatch between the film and substrate lattice vectors</p></td>
          <td>
                <code>0.01</code>
          </td>
        </tr>
        <tr>
          <td><code>max_area</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Maximum area of the interface unit cell cross section</p></td>
          <td>
                <code>500.0</code>
          </td>
        </tr>
        <tr>
          <td><code>interfacial_distance</code></td>
          <td>
                <code><span title="typing.Union">Union</span>[float, None]</code>
          </td>
          <td><p>Distance between the top atom in the substrate to the bottom atom of the film
If None, the interfacial distance will be predicted based on the average distance of the interlayer
spacing between the film and substrate materials.</p></td>
          <td>
                <code>2.0</code>
          </td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum in Angstroms</p></td>
          <td>
                <code>40.0</code>
          </td>
        </tr>
        <tr>
          <td><code>center</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines of the interface should be centered in the vacuum</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Attributes:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>substrate</code></td>
          <td>
                <code><a class="autorefs autorefs-internal" title="OgreInterface.surfaces.Surface" href="../surfaces/#OgreInterface.surfaces.Surface">Surface</a></code>
          </td>
          <td><p>Surface class of the substrate material</p></td>
        </tr>
        <tr>
          <td><code>film</code></td>
          <td>
                <code><a class="autorefs autorefs-internal" title="OgreInterface.surfaces.Surface" href="../surfaces/#OgreInterface.surfaces.Surface">Surface</a></code>
          </td>
          <td><p>Surface class of the film materials</p></td>
        </tr>
        <tr>
          <td><code>max_area_mismatch</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Tolarance of the area mismatch (eq. 2.1 in Zur and McGill)</p></td>
        </tr>
        <tr>
          <td><code>max_angle_strain</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Tolarence of the angle mismatch between the film and substrate lattice vectors</p></td>
        </tr>
        <tr>
          <td><code>max_linear_strain</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Tolarence of the length mismatch between the film and substrate lattice vectors</p></td>
        </tr>
        <tr>
          <td><code>max_area</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Maximum area of the interface unit cell cross section</p></td>
        </tr>
        <tr>
          <td><code>interfacial_distance</code></td>
          <td>
                <code><span title="typing.Union">Union</span>[float, None]</code>
          </td>
          <td><p>Distance between the top atom in the substrate to the bottom atom of the film
If None, the interfacial distance will be predicted based on the average distance of the interlayer
spacing between the film and substrate materials.</p></td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum in Angstroms</p></td>
        </tr>
        <tr>
          <td><code>center</code></td>
          <td>
          </td>
          <td><p>Determines of the interface should be centered in the vacuum</p></td>
        </tr>
        <tr>
          <td><code>match_list</code></td>
          <td>
                <code><span title="typing.List">List</span>[<span title="OgreInterface.lattice_match.OgreMatch">OgreMatch</span>]</code>
          </td>
          <td><p>List of OgreMatch objects for each interface generated</p></td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>OgreInterface/generate.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">InterfaceGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for generating interfaces from two bulk structures</span>

<span class="sd">    This class will use the lattice matching algorithm from Zur and McGill to generate</span>
<span class="sd">    commensurate interface structures between two inorganic crystalline materials.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from OgreInterface.generate import SurfaceGenerator, InterfaceGenerator</span>
<span class="sd">        &gt;&gt;&gt; subs = SurfaceGenerator.from_file(filename=&quot;POSCAR_sub&quot;, miller_index=[1,1,1], layers=5)</span>
<span class="sd">        &gt;&gt;&gt; films = SurfaceGenerator.from_file(filename=&quot;POSCAR_film&quot;, miller_index=[1,1,1], layers=5)</span>
<span class="sd">        &gt;&gt;&gt; interface_generator = InterfaceGenerator(substrate=subs[0], film=films[0])</span>
<span class="sd">        &gt;&gt;&gt; interfaces = interface_generator.generate_interfaces() # List of OgreInterface Interface objects</span>

<span class="sd">    Args:</span>
<span class="sd">        substrate: Surface class of the substrate material</span>
<span class="sd">        film: Surface class of the film materials</span>
<span class="sd">        max_area_mismatch: Tolarance of the area mismatch (eq. 2.1 in Zur and McGill)</span>
<span class="sd">        max_angle_strain: Tolarence of the angle mismatch between the film and substrate lattice vectors</span>
<span class="sd">        max_linear_strain: Tolarence of the length mismatch between the film and substrate lattice vectors</span>
<span class="sd">        max_area: Maximum area of the interface unit cell cross section</span>
<span class="sd">        interfacial_distance: Distance between the top atom in the substrate to the bottom atom of the film</span>
<span class="sd">            If None, the interfacial distance will be predicted based on the average distance of the interlayer</span>
<span class="sd">            spacing between the film and substrate materials.</span>
<span class="sd">        vacuum: Size of the vacuum in Angstroms</span>
<span class="sd">        center: Determines of the interface should be centered in the vacuum</span>

<span class="sd">    Attributes:</span>
<span class="sd">        substrate (Surface): Surface class of the substrate material</span>
<span class="sd">        film (Surface): Surface class of the film materials</span>
<span class="sd">        max_area_mismatch (float): Tolarance of the area mismatch (eq. 2.1 in Zur and McGill)</span>
<span class="sd">        max_angle_strain (float): Tolarence of the angle mismatch between the film and substrate lattice vectors</span>
<span class="sd">        max_linear_strain (float): Tolarence of the length mismatch between the film and substrate lattice vectors</span>
<span class="sd">        max_area (float): Maximum area of the interface unit cell cross section</span>
<span class="sd">        interfacial_distance (Union[float, None]): Distance between the top atom in the substrate to the bottom atom of the film</span>
<span class="sd">            If None, the interfacial distance will be predicted based on the average distance of the interlayer</span>
<span class="sd">            spacing between the film and substrate materials.</span>
<span class="sd">        vacuum (float): Size of the vacuum in Angstroms</span>
<span class="sd">        center: Determines of the interface should be centered in the vacuum</span>
<span class="sd">        match_list (List[OgreMatch]): List of OgreMatch objects for each interface generated</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">substrate</span><span class="p">:</span> <span class="n">Surface</span><span class="p">,</span>
        <span class="n">film</span><span class="p">:</span> <span class="n">Surface</span><span class="p">,</span>
        <span class="n">max_area_mismatch</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">max_angle_strain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">max_linear_strain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">max_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">500.0</span><span class="p">,</span>
        <span class="n">interfacial_distance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">40.0</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">substrate</span><span class="p">)</span> <span class="o">==</span> <span class="n">Surface</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="o">=</span> <span class="n">substrate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;InterfaceGenerator accepts &#39;ogre.core.Surface&#39; not &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">substrate</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">film</span><span class="p">)</span> <span class="o">==</span> <span class="n">Surface</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">film</span> <span class="o">=</span> <span class="n">film</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;InterfaceGenerator accepts &#39;ogre.core.Surface&#39; not &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">film</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_area_mismatch</span> <span class="o">=</span> <span class="n">max_area_mismatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_angle_strain</span> <span class="o">=</span> <span class="n">max_angle_strain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_linear_strain</span> <span class="o">=</span> <span class="n">max_linear_strain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_area</span> <span class="o">=</span> <span class="n">max_area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span> <span class="o">=</span> <span class="n">interfacial_distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vacuum</span> <span class="o">=</span> <span class="n">vacuum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_interface_props</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_generate_interface_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">zm</span> <span class="o">=</span> <span class="n">ZurMcGill</span><span class="p">(</span>
            <span class="n">film_vectors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="o">.</span><span class="n">inplane_vectors</span><span class="p">,</span>
            <span class="n">substrate_vectors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">inplane_vectors</span><span class="p">,</span>
            <span class="n">film_basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="o">.</span><span class="n">uvw_basis</span><span class="p">,</span>
            <span class="n">substrate_basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">uvw_basis</span><span class="p">,</span>
            <span class="n">max_area</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_area</span><span class="p">,</span>
            <span class="n">max_linear_strain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_linear_strain</span><span class="p">,</span>
            <span class="n">max_angle_strain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_angle_strain</span><span class="p">,</span>
            <span class="n">max_area_mismatch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_area_mismatch</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">match_list</span> <span class="o">=</span> <span class="n">zm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TolarenceError</span><span class="p">(</span>
                <span class="s2">&quot;No interfaces were found, please increase the tolarences.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">match_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">film_basis_vectors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sub_basis_vectors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">film_scale_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sub_scale_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_list</span><span class="p">):</span>
                <span class="n">film_basis_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">film_sl_basis</span><span class="p">)</span>
                <span class="n">sub_basis_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">substrate_sl_basis</span><span class="p">)</span>
                <span class="n">film_scale_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">film_sl_scale_factors</span><span class="p">)</span>
                <span class="n">sub_scale_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">substrate_sl_scale_factors</span><span class="p">)</span>

            <span class="n">film_basis_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">film_basis_vectors</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="n">sub_basis_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sub_basis_vectors</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int8</span>
            <span class="p">)</span>
            <span class="n">film_scale_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">film_scale_factors</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="n">sub_scale_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">sub_scale_factors</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

            <span class="n">film_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_miller_index_map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="o">.</span><span class="n">point_group_operations</span><span class="p">,</span> <span class="n">film_basis_vectors</span>
            <span class="p">)</span>
            <span class="n">sub_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_miller_index_map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">point_group_operations</span><span class="p">,</span> <span class="n">sub_basis_vectors</span>
            <span class="p">)</span>

            <span class="n">split_film_basis_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span>
                <span class="n">film_basis_vectors</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">split_sub_basis_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span>
                <span class="n">sub_basis_vectors</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">split_film_scale_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">film_scale_factors</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">split_sub_scale_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">sub_scale_factors</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">sort_vecs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_film_basis_vectors</span><span class="p">)):</span>
                <span class="n">fb</span> <span class="o">=</span> <span class="n">split_film_basis_vectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sb</span> <span class="o">=</span> <span class="n">split_sub_basis_vectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="n">split_film_scale_factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ss</span> <span class="o">=</span> <span class="n">split_sub_scale_factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sort_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">sub_map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                        <span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="n">sub_map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                        <span class="p">[</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">film_map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fb</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                        <span class="p">[</span><span class="n">fs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="n">film_map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fb</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sort_vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_vec</span><span class="p">)</span>

            <span class="n">sort_vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sort_vecs</span><span class="p">)</span>
            <span class="n">unique_sort_vecs</span><span class="p">,</span> <span class="n">unique_sort_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">sort_vecs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">unique_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">match_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_sort_inds</span><span class="p">]</span>

            <span class="n">sorted_matches</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">unique_matches</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">linear_strain</span><span class="p">)),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">angle_strain</span><span class="p">),</span>
                <span class="p">),</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">sorted_matches</span>

    <span class="k">def</span> <span class="nf">_get_miller_index_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operations</span><span class="p">,</span> <span class="n">miller_indices</span><span class="p">):</span>
        <span class="n">miller_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">miller_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">not_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">miller_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,jk&quot;</span><span class="p">,</span> <span class="n">operations</span><span class="p">,</span> <span class="n">miller_indices</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">unique_vecs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">miller_indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">not_used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">same_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">vec</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">not_used</span><span class="p">[</span><span class="n">same_inds</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">same_vecs</span> <span class="o">=</span> <span class="n">miller_indices</span><span class="p">[</span><span class="n">same_inds</span><span class="p">]</span>
                    <span class="n">optimal_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optimal_miller_index</span><span class="p">(</span><span class="n">same_vecs</span><span class="p">)</span>
                    <span class="n">unique_vecs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">optimal_vec</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">same_vecs</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">not_used</span><span class="p">[</span><span class="n">same_inds</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">unique_vecs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

        <span class="k">return</span> <span class="n">mapping</span>

    <span class="k">def</span> <span class="nf">_get_optimal_miller_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecs</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vecs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">like_signs</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diff</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">like_signs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">like_signs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_max</span> <span class="o">=</span> <span class="n">like_signs</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">like_signs</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">like_signs</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">first_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">second_max</span> <span class="o">=</span> <span class="n">first_max</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">first_max</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">first_max</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">second_max</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">second_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">second_max</span><span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">second_max</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_build_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i_dist</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">top_layer_dist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="o">.</span><span class="n">bottom_layer_dist</span>
            <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span>

        <span class="n">interface</span> <span class="o">=</span> <span class="n">Interface</span><span class="p">(</span>
            <span class="n">substrate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">,</span>
            <span class="n">film</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="p">,</span>
            <span class="n">interfacial_distance</span><span class="o">=</span><span class="n">i_dist</span><span class="p">,</span>
            <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span>
            <span class="n">vacuum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">interface</span>

    <span class="k">def</span> <span class="nf">generate_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a list of Interface objects from that matches found using the Zur and McGill lattice matching algorithm&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i_dist</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">top_layer_dist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="o">.</span><span class="n">bottom_layer_dist</span>
            <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span>

        <span class="n">interfaces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating Interfaces:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_list</span><span class="p">,</span> <span class="n">dynamic_ncols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">interface</span> <span class="o">=</span> <span class="n">Interface</span><span class="p">(</span>
                <span class="n">substrate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">,</span>
                <span class="n">film</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="p">,</span>
                <span class="n">interfacial_distance</span><span class="o">=</span><span class="n">i_dist</span><span class="p">,</span>
                <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span>
                <span class="n">vacuum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum</span><span class="p">,</span>
                <span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interface</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interfaces</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="OgreInterface.generate.InterfaceGenerator.generate_interfaces" class="doc doc-heading">
<code class="highlight language-python"><span class="n">generate_interfaces</span><span class="p">()</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Generates a list of Interface objects from that matches found using the Zur and McGill lattice matching algorithm</p>

      <details class="quote">
        <summary>Source code in <code>OgreInterface/generate.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">generate_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a list of Interface objects from that matches found using the Zur and McGill lattice matching algorithm&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">i_dist</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">top_layer_dist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="o">.</span><span class="n">bottom_layer_dist</span>
        <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfacial_distance</span>

    <span class="n">interfaces</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating Interfaces:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_list</span><span class="p">,</span> <span class="n">dynamic_ncols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">interface</span> <span class="o">=</span> <span class="n">Interface</span><span class="p">(</span>
            <span class="n">substrate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">,</span>
            <span class="n">film</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">film</span><span class="p">,</span>
            <span class="n">interfacial_distance</span><span class="o">=</span><span class="n">i_dist</span><span class="p">,</span>
            <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span>
            <span class="n">vacuum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interface</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">interfaces</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="OgreInterface.generate.OrganicSurfaceGenerator" class="doc doc-heading">
        <code>OrganicSurfaceGenerator</code>


</h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><a class="autorefs autorefs-internal" title="OgreInterface.generate.SurfaceGenerator" href="#OgreInterface.generate.SurfaceGenerator">SurfaceGenerator</a></code></p>

  
      <p>Class for generating surfaces from a given bulk structure.</p>
<p>The SurfaceGenerator classes generates surfaces with all possible terminations and contains
information pertinent to generating interfaces with the InterfaceGenerator.</p>

<p><strong>Examples:</strong></p>
    <p>Creating a SurfaceGenerator object using PyMatGen to load the structure:</p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">OgreInterface.generate</span> <span class="kn">import</span> <span class="n">SurfaceGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bulk</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s2">&quot;POSCAR_bulk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfaces</span> <span class="o">=</span> <span class="n">SurfaceGenerator</span><span class="p">(</span><span class="n">bulk</span><span class="o">=</span><span class="n">bulk</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">layers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surface</span> <span class="o">=</span> <span class="n">surfaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># OgreInterface.Surface object</span>
</code></pre></div>
    <p>Creating a SurfaceGenerator object using the build in from_file() method:</p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">OgreInterface.generate</span> <span class="kn">import</span> <span class="n">SurfaceGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfaces</span> <span class="o">=</span> <span class="n">SurfaceGenerator</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;POSCAR_bulk&quot;</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">layers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surface</span> <span class="o">=</span> <span class="n">surfaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># OgreInterface.Surface object</span>
</code></pre></div>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>bulk</code></td>
          <td>
                <code><span title="typing.Union">Union</span>[<span title="pymatgen.core.structure.Structure">Structure</span>, <span title="ase.Atoms">Atoms</span>]</code>
          </td>
          <td><p>Bulk crystal structure used to create the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>miller_index</code></td>
          <td>
                <code><span title="typing.List">List</span>[int]</code>
          </td>
          <td><p>Miller index of the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>layers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers to include in the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum to include over the surface in Angstroms</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>generate_all</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if all possible surface terminations are generated.</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
        <tr>
          <td><code>lazy</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the surfaces are actually generated, or if only the surface basis vectors are found.
(this is used for the MillerIndex search to make things faster)</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Attributes:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>slabs</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>List of OgreInterface Surface objects with different surface terminations.</p></td>
        </tr>
        <tr>
          <td><code>bulk_structure</code></td>
          <td>
                <code><span title="pymatgen.core.structure.Structure">Structure</span></code>
          </td>
          <td><p>Pymatgen Structure class for the conventional cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>bulk_atoms</code></td>
          <td>
                <code><span title="ase.Atoms">Atoms</span></code>
          </td>
          <td><p>ASE Atoms class for the conventional cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>primitive_structure</code></td>
          <td>
                <code><span title="pymatgen.core.structure.Structure">Structure</span></code>
          </td>
          <td><p>Pymatgen Structure class for the primitive cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>primitive_atoms</code></td>
          <td>
                <code><span title="ase.Atoms">Atoms</span></code>
          </td>
          <td><p>ASE Atoms class for the primitive cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>miller_index</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>Miller index of the surface</p></td>
        </tr>
        <tr>
          <td><code>layers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers to include in the surface</p></td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum to include over the surface in Angstroms</p></td>
        </tr>
        <tr>
          <td><code>generate_all</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if all possible surface terminations are generated.</p></td>
        </tr>
        <tr>
          <td><code>filter_ionic_slab</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the terminations of ionic crystals should be filtered out based on their
predicted stability calculated using the IonicScoreFunction</p></td>
        </tr>
        <tr>
          <td><code>lazy</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the surfaces are actually generated, or if only the surface basis vectors are found.
(this is used for the MillerIndex search to make things faster)</p></td>
        </tr>
        <tr>
          <td><code>oriented_bulk_structure</code></td>
          <td>
                <code><span title="pymatgen.core.structure.Structure">Structure</span></code>
          </td>
          <td><p>Pymatgen Structure class of the smallest building block of the slab,
which will eventually be used to build the slab supercell</p></td>
        </tr>
        <tr>
          <td><code>oriented_bulk_atoms</code></td>
          <td>
                <code><span title="ase.Atoms">Atoms</span></code>
          </td>
          <td><p>Pymatgen Atoms class of the smallest building block of the slab,
which will eventually be used to build the slab supercell</p></td>
        </tr>
        <tr>
          <td><code>uvw_basis</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>The miller indices of the slab lattice vectors.</p></td>
        </tr>
        <tr>
          <td><code>transformation_matrix</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>Transformation matrix used to convert from the bulk basis to the slab basis
(usefull for band unfolding calculations)</p></td>
        </tr>
        <tr>
          <td><code>inplane_vectors</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>The cartesian vectors of the in-plane lattice vectors.</p></td>
        </tr>
        <tr>
          <td><code>surface_normal</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>The normal vector of the surface</p></td>
        </tr>
        <tr>
          <td><code>c_projection</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The projections of the c-lattice vector onto the surface normal</p></td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>OgreInterface/generate.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">OrganicSurfaceGenerator</span><span class="p">(</span><span class="n">SurfaceGenerator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for generating surfaces from a given bulk structure.</span>

<span class="sd">    The SurfaceGenerator classes generates surfaces with all possible terminations and contains</span>
<span class="sd">    information pertinent to generating interfaces with the InterfaceGenerator.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating a SurfaceGenerator object using PyMatGen to load the structure:</span>
<span class="sd">        &gt;&gt;&gt; from OgreInterface.generate import SurfaceGenerator</span>
<span class="sd">        &gt;&gt;&gt; from pymatgen.core.structure import Structure</span>
<span class="sd">        &gt;&gt;&gt; bulk = Structure.from_file(&quot;POSCAR_bulk&quot;)</span>
<span class="sd">        &gt;&gt;&gt; surfaces = SurfaceGenerator(bulk=bulk, miller_index=[1, 1, 1], layers=5, vacuum=60)</span>
<span class="sd">        &gt;&gt;&gt; surface = surfaces[0] # OgreInterface.Surface object</span>

<span class="sd">        Creating a SurfaceGenerator object using the build in from_file() method:</span>
<span class="sd">        &gt;&gt;&gt; from OgreInterface.generate import SurfaceGenerator</span>
<span class="sd">        &gt;&gt;&gt; surfaces = SurfaceGenerator.from_file(filename=&quot;POSCAR_bulk&quot;, miller_index=[1, 1, 1], layers=5, vacuum=60)</span>
<span class="sd">        &gt;&gt;&gt; surface = surfaces[0] # OgreInterface.Surface object</span>

<span class="sd">    Args:</span>
<span class="sd">        bulk: Bulk crystal structure used to create the surface</span>
<span class="sd">        miller_index: Miller index of the surface</span>
<span class="sd">        layers: Number of layers to include in the surface</span>
<span class="sd">        vacuum: Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">        generate_all: Determines if all possible surface terminations are generated.</span>
<span class="sd">        lazy: Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">            (this is used for the MillerIndex search to make things faster)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        slabs (list): List of OgreInterface Surface objects with different surface terminations.</span>
<span class="sd">        bulk_structure (Structure): Pymatgen Structure class for the conventional cell of the input bulk structure</span>
<span class="sd">        bulk_atoms (Atoms): ASE Atoms class for the conventional cell of the input bulk structure</span>
<span class="sd">        primitive_structure (Structure): Pymatgen Structure class for the primitive cell of the input bulk structure</span>
<span class="sd">        primitive_atoms (Atoms): ASE Atoms class for the primitive cell of the input bulk structure</span>
<span class="sd">        miller_index (list): Miller index of the surface</span>
<span class="sd">        layers (int): Number of layers to include in the surface</span>
<span class="sd">        vacuum (float): Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">        generate_all (bool): Determines if all possible surface terminations are generated.</span>
<span class="sd">        filter_ionic_slab (bool): Determines if the terminations of ionic crystals should be filtered out based on their</span>
<span class="sd">            predicted stability calculated using the IonicScoreFunction</span>
<span class="sd">        lazy (bool): Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">            (this is used for the MillerIndex search to make things faster)</span>
<span class="sd">        oriented_bulk_structure (Structure): Pymatgen Structure class of the smallest building block of the slab,</span>
<span class="sd">            which will eventually be used to build the slab supercell</span>
<span class="sd">        oriented_bulk_atoms (Atoms): Pymatgen Atoms class of the smallest building block of the slab,</span>
<span class="sd">            which will eventually be used to build the slab supercell</span>
<span class="sd">        uvw_basis (list): The miller indices of the slab lattice vectors.</span>
<span class="sd">        transformation_matrix: Transformation matrix used to convert from the bulk basis to the slab basis</span>
<span class="sd">            (usefull for band unfolding calculations)</span>
<span class="sd">        inplane_vectors (list): The cartesian vectors of the in-plane lattice vectors.</span>
<span class="sd">        surface_normal (list): The normal vector of the surface</span>
<span class="sd">        c_projection (float): The projections of the c-lattice vector onto the surface normal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bulk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Structure</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">],</span>
        <span class="n">miller_index</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">generate_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get the primitive structure to label the molecuels</span>
        <span class="n">prim_bulk</span> <span class="o">=</span> <span class="n">bulk</span><span class="o">.</span><span class="n">get_primitive_structure</span><span class="p">()</span>

        <span class="c1"># Get the primitive to conventional transformation matrix</span>
        <span class="n">prim_to_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">conv_a_to_b</span><span class="p">(</span><span class="n">prim_bulk</span><span class="p">,</span> <span class="n">bulk</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">prim_to_conv</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="n">prim_to_conv</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mf">0.0</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;WARNING: Something went wrong with reducing the structure to it&#39;s primitive cell&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Label the molecules with dummy atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_molecules</span><span class="p">(</span><span class="n">prim_bulk</span><span class="p">)</span>

        <span class="c1"># Revert back to the supercell for the input into the SurfaceGenerator</span>
        <span class="n">labeled_bulk</span> <span class="o">=</span> <span class="n">prim_bulk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">labeled_bulk</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">prim_to_conv</span><span class="p">)</span>
        <span class="c1"># dummy_bulk = utils.replace_molecules_with_atoms(labeled_bulk)</span>

        <span class="c1"># Poscar(labeled_bulk).write_file(&quot;vis/POSCAR_mol_bulk&quot;)</span>
        <span class="c1"># utils._get_colored_molecules(</span>
        <span class="c1">#     labeled_bulk, &quot;vis/POSCAR_mol_bulk_colored&quot;</span>
        <span class="c1"># )</span>
        <span class="c1"># utils._get_colored_molecules(dummy_bulk, &quot;vis/POSCAR_com_bulk_colored&quot;)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">bulk</span><span class="o">=</span><span class="n">labeled_bulk</span><span class="p">,</span>
            <span class="n">miller_index</span><span class="o">=</span><span class="n">miller_index</span><span class="p">,</span>
            <span class="n">layers</span><span class="o">=</span><span class="n">layers</span><span class="p">,</span>
            <span class="n">vacuum</span><span class="o">=</span><span class="n">vacuum</span><span class="p">,</span>
            <span class="n">convert_to_conventional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">generate_all</span><span class="o">=</span><span class="n">generate_all</span><span class="p">,</span>
            <span class="n">filter_ionic_slabs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Extract the oriented bulk structure</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span>
        <span class="c1"># utils._get_colored_molecules(obs, &quot;vis/POSCAR_mol_obs_colored&quot;)</span>

        <span class="c1"># Replace the molecules with their cooresponding dummy atoms at their center of mass</span>
        <span class="n">dummy_obs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">replace_molecules_with_atoms</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        <span class="c1"># utils._get_colored_molecules(dummy_obs, &quot;vis/POSCAR_com_obs_colored&quot;)</span>

        <span class="c1"># Add oriented_bulk_equivalent site property</span>
        <span class="n">dummy_obs</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
            <span class="s2">&quot;oriented_bulk_equivalent&quot;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dummy_obs</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Replace the oriented bulk structure from the SurfaceGenerator class with the dummy atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span> <span class="o">=</span> <span class="n">dummy_obs</span>

        <span class="c1"># Generate the surfaces</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lazy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_slabs</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">miller_index</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">generate_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SelfOrganicSurfaceGenerator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creating a OrganicSurfaceGenerator from a file (i.e. POSCAR, cif, etc)</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: File path to the structure file</span>
<span class="sd">            miller_index: Miller index of the surface</span>
<span class="sd">            layers: Number of layers to include in the surface</span>
<span class="sd">            vacuum: Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">            generate_all: Determines if all possible surface terminations are generated</span>
<span class="sd">            lazy: Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">                (this is used for the MillerIndex search to make things faster)</span>

<span class="sd">        Returns:</span>
<span class="sd">            OrganicSurfaceGenerator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">structure</span><span class="p">,</span>
            <span class="n">miller_index</span><span class="p">,</span>
            <span class="n">layers</span><span class="p">,</span>
            <span class="n">vacuum</span><span class="p">,</span>
            <span class="n">generate_all</span><span class="p">,</span>
            <span class="n">lazy</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_label_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struc</span><span class="p">):</span>
        <span class="c1"># Create a structure graph so we can extract the molecules</span>
        <span class="n">struc_graph</span> <span class="o">=</span> <span class="n">StructureGraph</span><span class="o">.</span><span class="n">with_local_env_strategy</span><span class="p">(</span><span class="n">struc</span><span class="p">,</span> <span class="n">JmolNN</span><span class="p">())</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">struc_graph</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

        <span class="c1"># Extract all molecule subgraphs</span>
        <span class="n">subgraphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">)]</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">struc</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subgraph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subgraphs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">22</span>

        <span class="n">struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;dummy_species&quot;</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
            <span class="s2">&quot;molecule_index&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">labels</span> <span class="o">-</span> <span class="mi">22</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="OgreInterface.generate.OrganicSurfaceGenerator.from_file" class="doc doc-heading">
<code class="highlight language-python"><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">vacuum</span><span class="p">,</span> <span class="n">generate_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Creating a OrganicSurfaceGenerator from a file (i.e. POSCAR, cif, etc)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>File path to the structure file</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>miller_index</code></td>
          <td>
                <code><span title="typing.List">List</span>[int]</code>
          </td>
          <td><p>Miller index of the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>layers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers to include in the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum to include over the surface in Angstroms</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>generate_all</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if all possible surface terminations are generated</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
        <tr>
          <td><code>lazy</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the surfaces are actually generated, or if only the surface basis vectors are found.
(this is used for the MillerIndex search to make things faster)</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="OgreInterface.generate.SelfOrganicSurfaceGenerator">SelfOrganicSurfaceGenerator</span></code>
          </td>
          <td><p>OrganicSurfaceGenerator</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>OgreInterface/generate.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span>
<span class="normal">990</span>
<span class="normal">991</span>
<span class="normal">992</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">miller_index</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">generate_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SelfOrganicSurfaceGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creating a OrganicSurfaceGenerator from a file (i.e. POSCAR, cif, etc)</span>

<span class="sd">    Args:</span>
<span class="sd">        filename: File path to the structure file</span>
<span class="sd">        miller_index: Miller index of the surface</span>
<span class="sd">        layers: Number of layers to include in the surface</span>
<span class="sd">        vacuum: Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">        generate_all: Determines if all possible surface terminations are generated</span>
<span class="sd">        lazy: Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">            (this is used for the MillerIndex search to make things faster)</span>

<span class="sd">    Returns:</span>
<span class="sd">        OrganicSurfaceGenerator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">structure</span><span class="p">,</span>
        <span class="n">miller_index</span><span class="p">,</span>
        <span class="n">layers</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">,</span>
        <span class="n">generate_all</span><span class="p">,</span>
        <span class="n">lazy</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="OgreInterface.generate.SurfaceGenerator" class="doc doc-heading">
        <code>SurfaceGenerator</code>


</h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code><span title="collections.abc.Sequence">Sequence</span></code></p>

  
      <p>Class for generating surfaces from a given bulk structure.</p>
<p>The SurfaceGenerator classes generates surfaces with all possible terminations and contains
information pertinent to generating interfaces with the InterfaceGenerator.</p>

<p><strong>Examples:</strong></p>
    <p>Creating a SurfaceGenerator object using PyMatGen to load the structure:</p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">OgreInterface.generate</span> <span class="kn">import</span> <span class="n">SurfaceGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bulk</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s2">&quot;POSCAR_bulk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfaces</span> <span class="o">=</span> <span class="n">SurfaceGenerator</span><span class="p">(</span><span class="n">bulk</span><span class="o">=</span><span class="n">bulk</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">layers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surface</span> <span class="o">=</span> <span class="n">surfaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># OgreInterface.Surface object</span>
</code></pre></div>
    <p>Creating a SurfaceGenerator object using the build in from_file() method:</p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">OgreInterface.generate</span> <span class="kn">import</span> <span class="n">SurfaceGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfaces</span> <span class="o">=</span> <span class="n">SurfaceGenerator</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;POSCAR_bulk&quot;</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">layers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surface</span> <span class="o">=</span> <span class="n">surfaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># OgreInterface.Surface object</span>
</code></pre></div>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>bulk</code></td>
          <td>
                <code><span title="typing.Union">Union</span>[<span title="pymatgen.core.structure.Structure">Structure</span>, <span title="ase.Atoms">Atoms</span>]</code>
          </td>
          <td><p>Bulk crystal structure used to create the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>miller_index</code></td>
          <td>
                <code><span title="typing.List">List</span>[int]</code>
          </td>
          <td><p>Miller index of the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>layers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers to include in the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum to include over the surface in Angstroms</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>generate_all</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if all possible surface terminations are generated.</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
        <tr>
          <td><code>filter_ionic_slab</code></td>
          <td>
          </td>
          <td><p>Determines if the terminations of ionic crystals should be filtered out based on their
predicted stability calculated using the IonicScoreFunction</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lazy</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the surfaces are actually generated, or if only the surface basis vectors are found.
(this is used for the MillerIndex search to make things faster)</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Attributes:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>slabs</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>List of OgreInterface Surface objects with different surface terminations.</p></td>
        </tr>
        <tr>
          <td><code>bulk_structure</code></td>
          <td>
                <code><span title="pymatgen.core.structure.Structure">Structure</span></code>
          </td>
          <td><p>Pymatgen Structure class for the conventional cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>bulk_atoms</code></td>
          <td>
                <code><span title="ase.Atoms">Atoms</span></code>
          </td>
          <td><p>ASE Atoms class for the conventional cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>primitive_structure</code></td>
          <td>
                <code><span title="pymatgen.core.structure.Structure">Structure</span></code>
          </td>
          <td><p>Pymatgen Structure class for the primitive cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>primitive_atoms</code></td>
          <td>
                <code><span title="ase.Atoms">Atoms</span></code>
          </td>
          <td><p>ASE Atoms class for the primitive cell of the input bulk structure</p></td>
        </tr>
        <tr>
          <td><code>miller_index</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>Miller index of the surface</p></td>
        </tr>
        <tr>
          <td><code>layers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers to include in the surface</p></td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum to include over the surface in Angstroms</p></td>
        </tr>
        <tr>
          <td><code>generate_all</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if all possible surface terminations are generated.</p></td>
        </tr>
        <tr>
          <td><code>filter_ionic_slab</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the terminations of ionic crystals should be filtered out based on their
predicted stability calculated using the IonicScoreFunction</p></td>
        </tr>
        <tr>
          <td><code>lazy</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the surfaces are actually generated, or if only the surface basis vectors are found.
(this is used for the MillerIndex search to make things faster)</p></td>
        </tr>
        <tr>
          <td><code>oriented_bulk_structure</code></td>
          <td>
                <code><span title="pymatgen.core.structure.Structure">Structure</span></code>
          </td>
          <td><p>Pymatgen Structure class of the smallest building block of the slab,
which will eventually be used to build the slab supercell</p></td>
        </tr>
        <tr>
          <td><code>oriented_bulk_atoms</code></td>
          <td>
                <code><span title="ase.Atoms">Atoms</span></code>
          </td>
          <td><p>Pymatgen Atoms class of the smallest building block of the slab,
which will eventually be used to build the slab supercell</p></td>
        </tr>
        <tr>
          <td><code>uvw_basis</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>The miller indices of the slab lattice vectors.</p></td>
        </tr>
        <tr>
          <td><code>transformation_matrix</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>Transformation matrix used to convert from the bulk basis to the slab basis
(usefull for band unfolding calculations)</p></td>
        </tr>
        <tr>
          <td><code>inplane_vectors</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>The cartesian vectors of the in-plane lattice vectors.</p></td>
        </tr>
        <tr>
          <td><code>surface_normal</code></td>
          <td>
                <code>list</code>
          </td>
          <td><p>The normal vector of the surface</p></td>
        </tr>
        <tr>
          <td><code>c_projection</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The projections of the c-lattice vector onto the surface normal</p></td>
        </tr>
    </tbody>
  </table>


        <details class="quote">
          <summary>Source code in <code>OgreInterface/generate.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">SurfaceGenerator</span><span class="p">(</span><span class="n">Sequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for generating surfaces from a given bulk structure.</span>

<span class="sd">    The SurfaceGenerator classes generates surfaces with all possible terminations and contains</span>
<span class="sd">    information pertinent to generating interfaces with the InterfaceGenerator.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Creating a SurfaceGenerator object using PyMatGen to load the structure:</span>
<span class="sd">        &gt;&gt;&gt; from OgreInterface.generate import SurfaceGenerator</span>
<span class="sd">        &gt;&gt;&gt; from pymatgen.core.structure import Structure</span>
<span class="sd">        &gt;&gt;&gt; bulk = Structure.from_file(&quot;POSCAR_bulk&quot;)</span>
<span class="sd">        &gt;&gt;&gt; surfaces = SurfaceGenerator(bulk=bulk, miller_index=[1, 1, 1], layers=5, vacuum=60)</span>
<span class="sd">        &gt;&gt;&gt; surface = surfaces[0] # OgreInterface.Surface object</span>

<span class="sd">        Creating a SurfaceGenerator object using the build in from_file() method:</span>
<span class="sd">        &gt;&gt;&gt; from OgreInterface.generate import SurfaceGenerator</span>
<span class="sd">        &gt;&gt;&gt; surfaces = SurfaceGenerator.from_file(filename=&quot;POSCAR_bulk&quot;, miller_index=[1, 1, 1], layers=5, vacuum=60)</span>
<span class="sd">        &gt;&gt;&gt; surface = surfaces[0] # OgreInterface.Surface object</span>

<span class="sd">    Args:</span>
<span class="sd">        bulk: Bulk crystal structure used to create the surface</span>
<span class="sd">        miller_index: Miller index of the surface</span>
<span class="sd">        layers: Number of layers to include in the surface</span>
<span class="sd">        vacuum: Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">        generate_all: Determines if all possible surface terminations are generated.</span>
<span class="sd">        filter_ionic_slab: Determines if the terminations of ionic crystals should be filtered out based on their</span>
<span class="sd">            predicted stability calculated using the IonicScoreFunction</span>
<span class="sd">        lazy: Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">            (this is used for the MillerIndex search to make things faster)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        slabs (list): List of OgreInterface Surface objects with different surface terminations.</span>
<span class="sd">        bulk_structure (Structure): Pymatgen Structure class for the conventional cell of the input bulk structure</span>
<span class="sd">        bulk_atoms (Atoms): ASE Atoms class for the conventional cell of the input bulk structure</span>
<span class="sd">        primitive_structure (Structure): Pymatgen Structure class for the primitive cell of the input bulk structure</span>
<span class="sd">        primitive_atoms (Atoms): ASE Atoms class for the primitive cell of the input bulk structure</span>
<span class="sd">        miller_index (list): Miller index of the surface</span>
<span class="sd">        layers (int): Number of layers to include in the surface</span>
<span class="sd">        vacuum (float): Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">        generate_all (bool): Determines if all possible surface terminations are generated.</span>
<span class="sd">        filter_ionic_slab (bool): Determines if the terminations of ionic crystals should be filtered out based on their</span>
<span class="sd">            predicted stability calculated using the IonicScoreFunction</span>
<span class="sd">        lazy (bool): Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">            (this is used for the MillerIndex search to make things faster)</span>
<span class="sd">        oriented_bulk_structure (Structure): Pymatgen Structure class of the smallest building block of the slab,</span>
<span class="sd">            which will eventually be used to build the slab supercell</span>
<span class="sd">        oriented_bulk_atoms (Atoms): Pymatgen Atoms class of the smallest building block of the slab,</span>
<span class="sd">            which will eventually be used to build the slab supercell</span>
<span class="sd">        uvw_basis (list): The miller indices of the slab lattice vectors.</span>
<span class="sd">        transformation_matrix: Transformation matrix used to convert from the bulk basis to the slab basis</span>
<span class="sd">            (usefull for band unfolding calculations)</span>
<span class="sd">        inplane_vectors (list): The cartesian vectors of the in-plane lattice vectors.</span>
<span class="sd">        surface_normal (list): The normal vector of the surface</span>
<span class="sd">        c_projection (float): The projections of the c-lattice vector onto the surface normal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bulk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Structure</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">],</span>
        <span class="n">miller_index</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">convert_to_conventional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generate_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_ionic_slabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_conventional</span> <span class="o">=</span> <span class="n">convert_to_conventional</span>

        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bulk_structure</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bulk_atoms</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primitive_structure</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primitive_atoms</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bulk</span><span class="p">(</span><span class="n">atoms_or_struc</span><span class="o">=</span><span class="n">bulk</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_use_prim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bulk_structure</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primitive_structure</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_point_group_operations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_point_group_operations</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="n">miller_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="n">layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vacuum</span> <span class="o">=</span> <span class="n">vacuum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_all</span> <span class="o">=</span> <span class="n">generate_all</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_ionic_slabs</span> <span class="o">=</span> <span class="n">filter_ionic_slabs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span> <span class="o">=</span> <span class="n">lazy</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_atoms</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uvw_basis</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transformation_matrix</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inplane_vectors</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_normal</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_projection</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_oriented_bulk_structure</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_slabs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Surface</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;The slabs have not been generated yet, please use the generate_slabs() function to create them.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used to generate list of Surface objects if lazy=True&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_slabs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;The slabs are already generated upon initialization. This function is only needed if lazy=True&quot;</span>
            <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">miller_index</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">convert_to_conventional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generate_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_ionic_slabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SelfSurfaceGenerator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creating a SurfaceGenerator from a file (i.e. POSCAR, cif, etc)</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: File path to the structure file</span>
<span class="sd">            miller_index: Miller index of the surface</span>
<span class="sd">            layers: Number of layers to include in the surface</span>
<span class="sd">            vacuum: Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">            generate_all: Determines if all possible surface terminations are generated</span>
<span class="sd">            filter_ionic_slab: Determines if the terminations of ionic crystals should be filtered out based on their</span>
<span class="sd">                predicted stability calculated using the IonicScoreFunction</span>
<span class="sd">            lazy: Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">                (this is used for the MillerIndex search to make things faster)</span>

<span class="sd">        Returns:</span>
<span class="sd">            SurfaceGenerator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">structure</span><span class="p">,</span>
            <span class="n">miller_index</span><span class="p">,</span>
            <span class="n">layers</span><span class="p">,</span>
            <span class="n">vacuum</span><span class="p">,</span>
            <span class="n">convert_to_conventional</span><span class="p">,</span>
            <span class="n">generate_all</span><span class="p">,</span>
            <span class="n">filter_ionic_slabs</span><span class="p">,</span>
            <span class="n">lazy</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms_or_struc</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">atoms_or_struc</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atoms</span><span class="p">:</span>
            <span class="n">init_structure</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms_or_struc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">atoms_or_struc</span><span class="p">)</span> <span class="o">==</span> <span class="n">Structure</span><span class="p">:</span>
            <span class="n">init_structure</span> <span class="o">=</span> <span class="n">atoms_or_struc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;structure accepts &#39;pymatgen.core.structure.Structure&#39; or &#39;ase.Atoms&#39; not &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">atoms_or_struc</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_conventional</span><span class="p">:</span>
            <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">init_structure</span><span class="p">)</span>
            <span class="n">conventional_structure</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_conventional_standard_structure</span><span class="p">()</span>
            <span class="n">prim_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_symmetry_info</span><span class="p">(</span>
                <span class="n">conventional_structure</span><span class="p">,</span> <span class="n">return_primitive</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="c1"># prim_structure = sg.get_primitive_standard_structure()</span>
            <span class="n">prim_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">prim_structure</span><span class="p">)</span>
            <span class="n">conventional_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span>
                <span class="n">conventional_structure</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="n">conventional_structure</span><span class="p">,</span>
                <span class="n">conventional_atoms</span><span class="p">,</span>
                <span class="n">prim_structure</span><span class="p">,</span>
                <span class="n">prim_atoms</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;molecule_index&quot;</span> <span class="ow">in</span> <span class="n">init_structure</span><span class="o">.</span><span class="n">site_properties</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_symmetry_info_molecule</span><span class="p">(</span><span class="n">init_structure</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_symmetry_info</span><span class="p">(</span><span class="n">init_structure</span><span class="p">,</span> <span class="n">return_primitive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">init_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="p">()</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">init_structure</span><span class="p">)</span>

            <span class="n">prim_structure</span> <span class="o">=</span> <span class="n">init_structure</span><span class="o">.</span><span class="n">get_primitive_structure</span><span class="p">()</span>
            <span class="n">prim_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="p">()</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">prim_structure</span><span class="p">)</span>

            <span class="c1"># utils._get_colored_molecules(</span>
            <span class="c1">#     prim_structure, &quot;vis/POSCAR_mol_prim_color&quot;</span>
            <span class="c1"># )</span>

            <span class="k">return</span> <span class="n">init_structure</span><span class="p">,</span> <span class="n">init_atoms</span><span class="p">,</span> <span class="n">prim_structure</span><span class="p">,</span> <span class="n">prim_atoms</span>

    <span class="k">def</span> <span class="nf">_get_point_group_operations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bulk_structure</span><span class="p">)</span>
        <span class="n">point_group_operations</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_point_group_operations</span><span class="p">(</span><span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">operation_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">rotation_matrix</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">point_group_operations</span><span class="p">])</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">unique_operations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">operation_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unique_operations</span>

    <span class="k">def</span> <span class="nf">_add_symmetry_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struc</span><span class="p">,</span> <span class="n">return_primitive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">struc</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span>
        <span class="n">struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;bulk_wyckoff&quot;</span><span class="p">,</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;wyckoffs&quot;</span><span class="p">])</span>
        <span class="n">struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
            <span class="s2">&quot;bulk_equivalent&quot;</span><span class="p">,</span>
            <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_primitive</span><span class="p">:</span>
            <span class="n">prim_mapping</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapping_to_primitive&quot;</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">prim_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">prim_mapping</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">prim_bulk</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_primitive_standard_structure</span><span class="p">()</span>

            <span class="n">prim_bulk</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
                <span class="s2">&quot;bulk_wyckoff&quot;</span><span class="p">,</span>
                <span class="p">[</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;wyckoffs&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prim_inds</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">prim_bulk</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
                <span class="s2">&quot;bulk_equivalent&quot;</span><span class="p">,</span>
                <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">][</span><span class="n">prim_inds</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">prim_bulk</span>

    <span class="k">def</span> <span class="nf">_add_symmetry_info_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struc</span><span class="p">):</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">struc</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span>
        <span class="n">wyckoffs</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;wyckoffs&quot;</span><span class="p">]</span>
        <span class="n">equivalent_atoms</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">]</span>
        <span class="n">molecule_index</span> <span class="o">=</span> <span class="n">struc</span><span class="o">.</span><span class="n">site_properties</span><span class="p">[</span><span class="s2">&quot;molecule_index&quot;</span><span class="p">]</span>
        <span class="n">equivalent_molecules</span> <span class="o">=</span> <span class="p">[</span><span class="n">molecule_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">equivalent_atoms</span><span class="p">]</span>
        <span class="n">struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;bulk_wyckoff&quot;</span><span class="p">,</span> <span class="n">wyckoffs</span><span class="p">)</span>
        <span class="n">struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;bulk_equivalent&quot;</span><span class="p">,</span> <span class="n">equivalent_molecules</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_oriented_bulk_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bulk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_structure</span>
        <span class="n">prim_bulk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive_structure</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="n">bulk</span><span class="o">.</span><span class="n">lattice</span>
        <span class="n">prim_lattice</span> <span class="o">=</span> <span class="n">prim_bulk</span><span class="o">.</span><span class="n">lattice</span>

        <span class="n">recip_lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span>

        <span class="n">miller_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span>

        <span class="n">d_hkl</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">d_hkl</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>

        <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">recip_lattice</span><span class="o">.</span><span class="n">metric_tensor</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">prim_normal_vector</span> <span class="o">=</span> <span class="n">prim_lattice</span><span class="o">.</span><span class="n">get_fractional_coords</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">prim_miller_index</span> <span class="o">=</span> <span class="n">prim_normal_vector</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prim_lattice</span><span class="o">.</span><span class="n">metric_tensor</span><span class="p">)</span>
        <span class="n">prim_miller_index</span> <span class="o">=</span> <span class="n">prim_miller_index</span>

        <span class="n">prim_miller_index</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_get_reduced_vector</span><span class="p">(</span>
            <span class="n">prim_miller_index</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">normal_vector</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_prim</span><span class="p">:</span>
            <span class="n">intercepts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">miller_index</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">non_zero_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intercepts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lattice_for_slab</span> <span class="o">=</span> <span class="n">lattice</span>
            <span class="n">struc_for_slab</span> <span class="o">=</span> <span class="n">bulk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">intercepts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prim_miller_index</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">non_zero_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intercepts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_hkl</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">d_hkl</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>
            <span class="n">lattice_for_slab</span> <span class="o">=</span> <span class="n">prim_lattice</span>
            <span class="n">struc_for_slab</span> <span class="o">=</span> <span class="n">prim_bulk</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_zero_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">basis</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">non_zero_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*=</span> <span class="n">intercepts</span><span class="p">[</span>
                <span class="n">non_zero_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">dot_products</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal_vector</span><span class="p">)</span>
            <span class="n">sort_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dot_products</span><span class="p">)</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">sort_inds</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>

            <span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_zero_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">intercepts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">vec1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="n">intercepts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_zero_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">intercepts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">possible_vecs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">center_inds</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]:</span>
                <span class="n">vec1</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">points</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="n">center_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                    <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="n">center_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
                <span class="p">)</span>
                <span class="n">vec2</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">points</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="n">center_inds</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
                    <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">non_zero_points</span><span class="p">[</span><span class="n">center_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
                <span class="p">)</span>
                <span class="n">cart_vec1</span> <span class="o">=</span> <span class="n">lattice_for_slab</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
                <span class="n">cart_vec2</span> <span class="o">=</span> <span class="n">lattice_for_slab</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cart_vec1</span><span class="p">,</span> <span class="n">cart_vec2</span><span class="p">)</span>
                    <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cart_vec1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cart_vec2</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">possible_vecs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

            <span class="n">chosen_vec1</span><span class="p">,</span> <span class="n">chosen_vec2</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">possible_vecs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">chosen_vec1</span><span class="p">,</span> <span class="n">chosen_vec2</span><span class="p">])</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_reduced_basis</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">max_normal_search</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="n">index_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_normal_search</span><span class="p">,</span> <span class="n">max_normal_search</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">uvw</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">index_range</span><span class="p">,</span> <span class="n">index_range</span><span class="p">,</span> <span class="n">index_range</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">uvw</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">basis</span><span class="p">,</span> <span class="n">uvw</span><span class="p">]))</span>
                <span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">vec</span> <span class="o">=</span> <span class="n">lattice_for_slab</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>
                <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">)</span> <span class="o">-</span> <span class="n">d_hkl</span><span class="p">)</span>
                <span class="n">vec_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
                <span class="n">cosine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span> <span class="o">/</span> <span class="n">vec_length</span><span class="p">,</span> <span class="n">normal_vector</span><span class="p">)</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">uvw</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">cosine</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">vec_length</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cosine</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                    <span class="c1"># If cosine of 1 is found, no need to search further.</span>
                    <span class="k">break</span>
            <span class="c1"># We want the indices with the maximum absolute cosine,</span>
            <span class="c1"># but smallest possible length.</span>
            <span class="n">uvw</span><span class="p">,</span> <span class="n">cosine</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">candidates</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">basis</span><span class="p">,</span> <span class="n">uvw</span><span class="p">])</span>

        <span class="n">init_oriented_struc</span> <span class="o">=</span> <span class="n">struc_for_slab</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">init_oriented_struc</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>

        <span class="n">cart_basis</span> <span class="o">=</span> <span class="n">init_oriented_struc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cart_basis</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ab_switch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="n">init_oriented_struc</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">ab_switch</span><span class="p">)</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">ab_switch</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
            <span class="n">cart_basis</span> <span class="o">=</span> <span class="n">init_oriented_struc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>

        <span class="n">cross_ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">cart_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cart_basis</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cross_ab</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cross_ab</span><span class="p">)</span>
        <span class="n">cross_ac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">cart_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cross_ab</span><span class="p">)</span>
        <span class="n">cross_ac</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cross_ac</span><span class="p">)</span>

        <span class="n">ortho_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">cart_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cart_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">cross_ac</span><span class="p">,</span>
                <span class="n">cross_ab</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">to_planar_operation</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span>
            <span class="n">ortho_basis</span><span class="p">,</span> <span class="n">translation_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># if &quot;molecules&quot; in init_oriented_struc.site_properties:</span>
        <span class="c1">#     for site in init_oriented_struc:</span>
        <span class="c1">#         mol = site.properties[&quot;molecules&quot;]</span>
        <span class="c1">#         planar_mol = mol.copy()</span>
        <span class="c1">#         planar_mol.translate_sites(range(len(mol)), site.coords)</span>
        <span class="c1">#         planar_mol.apply_operation(to_planar_operation)</span>
        <span class="c1">#         centered_mol = planar_mol.get_centered_molecule()</span>
        <span class="c1">#         site.properties[&quot;molecules&quot;] = centered_mol</span>

        <span class="n">planar_oriented_struc</span> <span class="o">=</span> <span class="n">init_oriented_struc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">apply_operation</span><span class="p">(</span><span class="n">to_planar_operation</span><span class="p">)</span>

        <span class="n">planar_matrix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="n">new_a</span><span class="p">,</span> <span class="n">new_b</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">reduce_vectors_zur_and_mcgill</span><span class="p">(</span>
            <span class="n">planar_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">planar_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

        <span class="n">a_norm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">a</span>
        <span class="p">)</span>
        <span class="n">a_to_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">a_norm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">a_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">a_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_norm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="n">a_to_i_operation</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span>
            <span class="n">a_to_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">translation_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># if &quot;molecules&quot; in planar_oriented_struc.site_properties:</span>
        <span class="c1">#     for site in planar_oriented_struc:</span>
        <span class="c1">#         mol = site.properties[&quot;molecules&quot;]</span>
        <span class="c1">#         a_to_i_mol = mol.copy()</span>
        <span class="c1">#         a_to_i_mol.translate_sites(range(len(mol)), site.coords)</span>
        <span class="c1">#         a_to_i_mol.apply_operation(a_to_i_operation)</span>
        <span class="c1">#         centered_mol = a_to_i_mol.get_centered_molecule()</span>
        <span class="c1">#         site.properties[&quot;molecules&quot;] = centered_mol</span>

        <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">apply_operation</span><span class="p">(</span><span class="n">a_to_i_operation</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;molecule_index&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">site_properties</span><span class="p">:</span>
            <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
                <span class="s2">&quot;oriented_bulk_equivalent&quot;</span><span class="p">,</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">planar_oriented_struc</span><span class="p">))),</span>
            <span class="p">)</span>

        <span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">planar_oriented_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="p">()</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span>
            <span class="n">planar_oriented_struc</span>
        <span class="p">)</span>

        <span class="n">final_matrix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">planar_oriented_struc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="n">final_basis</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
        <span class="n">final_basis</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_reduced_basis</span><span class="p">(</span><span class="n">final_basis</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">transformation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">final_basis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_prim</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">final_basis</span><span class="p">):</span>
                <span class="n">cart_coords</span> <span class="o">=</span> <span class="n">prim_lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">conv_frac_coords</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">get_fractional_coords</span><span class="p">(</span><span class="n">cart_coords</span><span class="p">)</span>
                <span class="n">conv_frac_coords</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_get_reduced_vector</span><span class="p">(</span><span class="n">conv_frac_coords</span><span class="p">)</span>
                <span class="n">final_basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv_frac_coords</span>

        <span class="n">inplane_vectors</span> <span class="o">=</span> <span class="n">final_matrix</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">final_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">final_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">norm</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">final_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">norm_proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">final_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">planar_oriented_struc</span><span class="p">,</span>
            <span class="n">planar_oriented_atoms</span><span class="p">,</span>
            <span class="n">final_basis</span><span class="p">,</span>
            <span class="n">transformation_matrix</span><span class="p">,</span>
            <span class="n">inplane_vectors</span><span class="p">,</span>
            <span class="n">norm</span><span class="p">,</span>
            <span class="n">norm_proj</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_possible_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">):</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Clustering does not work when there is only one data point.</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">shift</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shift</span><span class="p">)]</span>

        <span class="c1"># We cluster the sites according to the c coordinates. But we need to</span>
        <span class="c1"># take into account PBC. Let&#39;s compute a fractional c-coordinate</span>
        <span class="c1"># distance matrix that accounts for PBC.</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="c1"># h = self.oriented_bulk_structure.lattice.matrix[-1, -1]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_projection</span>
        <span class="c1"># Projection of c lattice vector in</span>
        <span class="c1"># direction of surface normal.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">cdist</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">cdist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cdist</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">cdist</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdist</span>
                <span class="n">dist_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdist</span>

        <span class="n">condensed_m</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">condensed_m</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">fcluster</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>

        <span class="c1"># Generate dict of cluster# to c val - doesn&#39;t matter what the c is.</span>
        <span class="n">c_loc</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)}</span>

        <span class="c1"># Put all c into the unit cell.</span>
        <span class="n">possible_c</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">c_loc</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>

        <span class="c1"># Calculate the shifts</span>
        <span class="n">nshifts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_c</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nshifts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nshifts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># There is an additional shift between the first and last c</span>
                <span class="c1"># coordinate. But this needs special handling because of PBC.</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">possible_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">possible_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">shift</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">possible_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">possible_c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span>

        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shifts</span>

    <span class="k">def</span> <span class="nf">_get_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes in shift value for the c lattice direction and</span>
<span class="sd">        generates a slab based on the given shift. You should rarely use this</span>
<span class="sd">        method. Instead, it is used by other generation algorithms to obtain</span>
<span class="sd">        all slabs.</span>

<span class="sd">        Args:</span>
<span class="sd">            shift (float): A shift value in Angstrom that determines how much a</span>
<span class="sd">                slab should be shifted.</span>
<span class="sd">            tol (float): Tolerance to determine primitive cell.</span>
<span class="sd">            energy (float): An energy to assign to the slab.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Slab) A Slab object with a particular shifted oriented unit cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">slab_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">slab_base</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slab_base</span><span class="p">)),</span>
            <span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">shift</span><span class="p">],</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">z_coords</span> <span class="o">=</span> <span class="n">slab_base</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bot_z</span> <span class="o">=</span> <span class="n">z_coords</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">top_z</span> <span class="o">=</span> <span class="n">z_coords</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="n">max_z_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">top_z</span><span class="p">,</span> <span class="n">z_coords</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">max_z_inds</span><span class="p">:</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">slab_base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">distance_and_image_from_frac_coords</span><span class="p">(</span>
                <span class="n">fcoords</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="n">horiz_shift_ind</span> <span class="o">=</span> <span class="n">max_z_inds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)]</span>
        <span class="n">horiz_shift</span> <span class="o">=</span> <span class="o">-</span><span class="n">slab_base</span><span class="p">[</span><span class="n">horiz_shift_ind</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="n">horiz_shift</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">slab_base</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slab_base</span><span class="p">)),</span>
            <span class="n">vector</span><span class="o">=</span><span class="n">horiz_shift</span><span class="p">,</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">slab_base</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">slab_base</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">bottom_layer_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bot_z</span> <span class="o">-</span> <span class="p">(</span><span class="n">top_z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">init_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">top_layer_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">bot_z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">top_z</span><span class="p">)</span> <span class="o">*</span> <span class="n">init_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">vacuum_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacuum</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_projection</span>

        <span class="k">if</span> <span class="n">vacuum_scale</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vacuum_scale</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">vacuum_scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vacuum_scale</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">non_orthogonal_slab</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_layer_supercelll</span><span class="p">(</span>
            <span class="n">structure</span><span class="o">=</span><span class="n">slab_base</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">,</span> <span class="n">vacuum_scale</span><span class="o">=</span><span class="n">vacuum_scale</span>
        <span class="p">)</span>
        <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">new_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_normal</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_normal</span>
        <span class="n">vacuum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_bulk_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">vacuum_scale</span>

        <span class="n">orthogonal_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">new_c</span><span class="p">])</span>
        <span class="n">orthogonal_slab</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">Lattice</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">orthogonal_matrix</span><span class="p">),</span>
            <span class="n">species</span><span class="o">=</span><span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span>
            <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">center_shift</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">vacuum_scale</span> <span class="o">/</span> <span class="p">(</span><span class="n">vacuum_scale</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">))</span>
        <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_orthogonal_slab</span><span class="p">)),</span>
            <span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">center_shift</span><span class="p">],</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orthogonal_slab</span><span class="p">)),</span>
            <span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">center_shift</span><span class="p">],</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">top_z</span> <span class="o">=</span> <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">top_cart</span> <span class="o">=</span> <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">top_z</span>
        <span class="n">top_cart</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orthogonal_slab</span><span class="p">)),</span>
            <span class="n">vector</span><span class="o">=-</span><span class="n">top_cart</span><span class="p">,</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">orthogonal_slab</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">slab_base</span><span class="p">,</span>
            <span class="n">orthogonal_slab</span><span class="p">,</span>
            <span class="n">non_orthogonal_slab</span><span class="p">,</span>
            <span class="n">bottom_layer_dist</span><span class="p">,</span>
            <span class="n">top_layer_dist</span><span class="p">,</span>
            <span class="n">vacuum</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to generate slab structures with all unique</span>
<span class="sd">        surface terminations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Surface classes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine if all possible terminations are generated</span>
        <span class="n">possible_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_possible_shifts</span><span class="p">()</span>
        <span class="n">shifted_slab_bases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">orthogonal_slabs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">non_orthogonal_slabs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bottom_layer_dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">top_layer_dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_all</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">shifted_slab_base</span><span class="p">,</span>
                <span class="n">orthogonal_slab</span><span class="p">,</span>
                <span class="n">non_orthogonal_slab</span><span class="p">,</span>
                <span class="n">bottom_layer_dist</span><span class="p">,</span>
                <span class="n">top_layer_dist</span><span class="p">,</span>
                <span class="n">actual_vacuum</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slab</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">possible_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">sort_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">sort_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">shifted_slab_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shifted_slab_base</span><span class="p">)</span>
            <span class="n">orthogonal_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orthogonal_slab</span><span class="p">)</span>
            <span class="n">non_orthogonal_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_orthogonal_slab</span><span class="p">)</span>
            <span class="n">bottom_layer_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bottom_layer_dist</span><span class="p">)</span>
            <span class="n">top_layer_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_layer_dist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">possible_shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possible_shifts</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">shifted_slab_base</span><span class="p">,</span>
                    <span class="n">orthogonal_slab</span><span class="p">,</span>
                    <span class="n">non_orthogonal_slab</span><span class="p">,</span>
                    <span class="n">bottom_layer_dist</span><span class="p">,</span>
                    <span class="n">top_layer_dist</span><span class="p">,</span>
                    <span class="n">actual_vacuum</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slab</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">possible_shift</span><span class="p">)</span>
                <span class="n">orthogonal_slab</span><span class="o">.</span><span class="n">sort_index</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">non_orthogonal_slab</span><span class="o">.</span><span class="n">sort_index</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">shifted_slab_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shifted_slab_base</span><span class="p">)</span>
                <span class="n">orthogonal_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orthogonal_slab</span><span class="p">)</span>
                <span class="n">non_orthogonal_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_orthogonal_slab</span><span class="p">)</span>
                <span class="n">bottom_layer_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bottom_layer_dist</span><span class="p">)</span>
                <span class="n">top_layer_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_layer_dist</span><span class="p">)</span>

        <span class="n">surfaces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_prim</span><span class="p">:</span>
            <span class="n">base_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive_structure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_structure</span>

        <span class="c1"># Loop through slabs to ensure that they are all properly oriented and reduced</span>
        <span class="c1"># Return Surface objects</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orthogonal_slabs</span><span class="p">):</span>
            <span class="c1"># Create the Surface object</span>
            <span class="n">surface</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span>
                <span class="n">orthogonal_slab</span><span class="o">=</span><span class="n">slab</span><span class="p">,</span>
                <span class="n">non_orthogonal_slab</span><span class="o">=</span><span class="n">non_orthogonal_slabs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">oriented_bulk</span><span class="o">=</span><span class="n">shifted_slab_bases</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">bulk</span><span class="o">=</span><span class="n">base_structure</span><span class="p">,</span>
                <span class="n">transformation_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation_matrix</span><span class="p">,</span>
                <span class="n">miller_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
                <span class="n">layers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">,</span>
                <span class="n">vacuum</span><span class="o">=</span><span class="n">actual_vacuum</span><span class="p">,</span>
                <span class="n">uvw_basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uvw_basis</span><span class="p">,</span>
                <span class="n">point_group_operations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_point_group_operations</span><span class="p">,</span>
                <span class="n">bottom_layer_dist</span><span class="o">=</span><span class="n">bottom_layer_dists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">top_layer_dist</span><span class="o">=</span><span class="n">top_layer_dists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">termination_index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">surface_normal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_normal</span><span class="p">,</span>
                <span class="n">c_projection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_projection</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">surfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">surfaces</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nslabs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of slabs generated by the SurfaceGenerator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">terminations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the terminations of each slab generated by the SurfaceGenerator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_termination</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">)</span>
        <span class="p">}</span>
</code></pre></div></td></tr></table></div>
        </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="OgreInterface.generate.SurfaceGenerator.nslabs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">nslabs</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Return the number of slabs generated by the SurfaceGenerator</p>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="OgreInterface.generate.SurfaceGenerator.terminations" class="doc doc-heading">
<code class="highlight language-python"><span class="n">terminations</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Return the terminations of each slab generated by the SurfaceGenerator</p>
  </div>

</div>



<div class="doc doc-object doc-function">



<h3 id="OgreInterface.generate.SurfaceGenerator.from_file" class="doc doc-heading">
<code class="highlight language-python"><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">vacuum</span><span class="p">,</span> <span class="n">convert_to_conventional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">generate_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_ionic_slabs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Creating a SurfaceGenerator from a file (i.e. POSCAR, cif, etc)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
                <code>str</code>
          </td>
          <td><p>File path to the structure file</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>miller_index</code></td>
          <td>
                <code><span title="typing.List">List</span>[int]</code>
          </td>
          <td><p>Miller index of the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>layers</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Number of layers to include in the surface</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>vacuum</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the vacuum to include over the surface in Angstroms</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>generate_all</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if all possible surface terminations are generated</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
        <tr>
          <td><code>filter_ionic_slab</code></td>
          <td>
          </td>
          <td><p>Determines if the terminations of ionic crystals should be filtered out based on their
predicted stability calculated using the IonicScoreFunction</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lazy</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>Determines if the surfaces are actually generated, or if only the surface basis vectors are found.
(this is used for the MillerIndex search to make things faster)</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="OgreInterface.generate.SelfSurfaceGenerator">SelfSurfaceGenerator</span></code>
          </td>
          <td><p>SurfaceGenerator</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>OgreInterface/generate.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">miller_index</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">convert_to_conventional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">generate_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_ionic_slabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SelfSurfaceGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creating a SurfaceGenerator from a file (i.e. POSCAR, cif, etc)</span>

<span class="sd">    Args:</span>
<span class="sd">        filename: File path to the structure file</span>
<span class="sd">        miller_index: Miller index of the surface</span>
<span class="sd">        layers: Number of layers to include in the surface</span>
<span class="sd">        vacuum: Size of the vacuum to include over the surface in Angstroms</span>
<span class="sd">        generate_all: Determines if all possible surface terminations are generated</span>
<span class="sd">        filter_ionic_slab: Determines if the terminations of ionic crystals should be filtered out based on their</span>
<span class="sd">            predicted stability calculated using the IonicScoreFunction</span>
<span class="sd">        lazy: Determines if the surfaces are actually generated, or if only the surface basis vectors are found.</span>
<span class="sd">            (this is used for the MillerIndex search to make things faster)</span>

<span class="sd">    Returns:</span>
<span class="sd">        SurfaceGenerator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">structure</span><span class="p">,</span>
        <span class="n">miller_index</span><span class="p">,</span>
        <span class="n">layers</span><span class="p">,</span>
        <span class="n">vacuum</span><span class="p">,</span>
        <span class="n">convert_to_conventional</span><span class="p">,</span>
        <span class="n">generate_all</span><span class="p">,</span>
        <span class="n">filter_ionic_slabs</span><span class="p">,</span>
        <span class="n">lazy</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="OgreInterface.generate.SurfaceGenerator.generate_slabs" class="doc doc-heading">
<code class="highlight language-python"><span class="n">generate_slabs</span><span class="p">()</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Used to generate list of Surface objects if lazy=True</p>

      <details class="quote">
        <summary>Source code in <code>OgreInterface/generate.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">generate_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Used to generate list of Surface objects if lazy=True&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_slabs</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;The slabs are already generated upon initialization. This function is only needed if lazy=True&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="OgreInterface.generate.TolarenceError" class="doc doc-heading">
        <code>TolarenceError</code>


</h2>


  <div class="doc doc-contents ">
      <p class="doc doc-class-bases">
        Bases: <code>RuntimeError</code></p>

  
      <p>Class to handle errors when no interfaces are found for a given tolarence setting.</p>


        <details class="quote">
          <summary>Source code in <code>OgreInterface/generate.py</code></summary>
          <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">TolarenceError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to handle errors when no interfaces are found for a given tolarence setting.&quot;&quot;&quot;</span>

    <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
        </details>

  </div>

</div>




  </div>

  </div>

</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.db81ec45.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.a00a7c5e.min.js"></script>
      
    
  </body>
</html>